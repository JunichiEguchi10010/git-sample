DataBase データベース 正規化について　20250507

主キー（Primary Key）とは、データベースのテーブル内で各レコードを一意に識別できる属性（または属性の組み合わせ） のことです。
このキーによって、テーブル内の各行がユニークに識別され、データの整合性が確保されます。

主キーは、以下の特性を満たす必要があります：

一意性（Uniqueness）
同じテーブル内で、主キーの値が重複することは許されません。
例: 「社員ID」が主キーの場合、同じIDを持つ2人の社員が存在することはできない。

非NULL性（Non-nullability）
主キーの値は NULL（未定義）になることは許されません。
すべてのレコードがユニークに識別されるため、主キーが欠けると識別が不可能になる。

不変性（Immutability）
一度設定された主キーの値は、原則として変更されない。
変更されると、それに関連するデータの整合性が損なわれる可能性があるため。

最小性（Minimality）
主キーは 最小限の属性で構成されるべき。
不必要な列を含めず、本当に必要な属性 のみで構成することが望ましい。

主キーの種類
主キーには以下の種類があります：

単一主キー（Single Primary Key）
1つの列（属性）のみでレコードを識別できるもの。
例: 社員ID, 注文ID

複合主キー（Composite Primary Key）
複数の列を組み合わせて レコードを一意に識別するもの。
例: 学生ID + 授業ID, 注文ID + 商品ID
**複合主キーがある場合に、第2正規化を適用することでデータの冗長性を減らし、整合性を向上させる**

自然主キー（Natural Primary Key）
実際の業務上意味を持つデータを主キーとするもの。
例: マイナンバー, ISBN（書籍の識別番号）

代理主キー（Surrogate Primary Key）
意味を持たないIDを追加し、一意性を保証するもの。
例: オートインクリメントされた識別番号（例: ユーザーID）



**第1正規形（1NF）のポイント**
（1NF）は、データベースの正規化の最初の段階であり、データを整理して、各セルに単一の値を持たせる ことを目的としています。

第1正規形の定義
第1正規形を満たすためには、以下の条件を満たす必要があります：

各列（フィールド）は単一の値を持つ

1つのセルに複数の値を含めてはいけない。

各行（レコード）は一意に識別できる

主キーを設定し、各レコードを識別できるようにする。

繰り返しのグループを排除する

同じ種類のデータを複数の列に分けるのではなく、適切なテーブル構造に整理する。

具体例
例えば、以下のような「学生の履修情報」テーブルがあるとします。

学生ID                  	名前                	履修科目
101	                        田中                	数学, 英語
102	                        鈴木	                英語, 理科
このテーブルでは、「履修科目」の列に 複数の値（数学, 英語など）が含まれている ため、第1正規形を満たしていません。

第1正規形への変換
この問題を解決するために、**各科目を別の行として分割** します。

学生ID	                    名前	                履修科目
101	                        田中                	数学
101	                        田中                	英語
102	                        鈴木	                英語
102	                        鈴木	                理科
こうすることで、各セルに単一の値が入り、第1正規形を満たす ことになります。
**→科目を分ける**

第1正規形のメリット
データの整合性が向上 → 各値が明確に管理されるため、検索や更新が容易になる。
データの冗長性が減少 → 不要な繰り返しを排除し、データの管理が効率化される。
検索や集計がしやすくなる → 例えば「英語を履修している学生」を簡単に検索できる。


**第2正規形（2NF）のポイント**
第2正規化では、**部分関数従属** を解消することが目的です。
 部分関数従属とは、複合主キーの一部にのみ依存するデータがある状態 を指します。

複合主キーとの関係
複合主キーを持つテーブルでは、主キーの一部にのみ依存するデータが存在することがあります。 
この場合、第2正規化を適用することで、依存関係を整理し、適切なテーブル構造に分割 します。
**→依存関係の列を切り分ける**

具体例
例えば、以下のような 履修管理テーブル を考えます。

学籍番号	授業名      	教員名
101	        数学	        田中
101	        英語	        斎藤
102	        数学	        田中
この場合、「学籍番号」と「授業名」の組み合わせが複合主キー ですが、 「教員名」は 授業名だけに依存 しており、学籍番号とは関係ありません。

第2正規化の適用
この問題を解決するために、「授業名」と「教員名」を別テーブルに分割 します。

① 履修情報テーブル（複合主キー）
学籍番号	授業名
101	数学
101	英語
102	数学

② 授業情報テーブル（単一主キー）
授業名	教員名
数学	田中
英語	斎藤
こうすることで、「教員名」が授業名にのみ依存する形になり、データの整合性が向上 します。

まとめ
複合主キーがある場合、第2正規化を適用すると部分関数従属を解消できる
データを適切に分割することで、冗長性を減らし、更新時の整合性を確保できる
特定の属性が主キーの一部にのみ依存している場合は、別テーブルに分割する


**第3正規形（3NF）のポイント**
データベースの正規化の中でも特に重要な段階であり、**推移的依存を排除する** ことを目的としています。

第3正規形（3NF）の定義
第2正規形（2NF） を満たした上で、主キー以外の列が、他の非キー列に依存していない 状態を指します。
**→IDを振って分ける**

推移的依存とは？
推移的依存とは、ある非キー列が、主キーではなく別の非キー列に依存している状態 のことです。

例えば、以下のような「社員情報」テーブルを考えます。
社員ID	                    役職                    	給与
101	                        マネージャー            	500万
102	                        エンジニア                 	400万
この場合、「給与」は「役職」に依存しており、「社員ID」には直接依存していません。
つまり、「給与」は「役職」を通じて間接的に「社員ID」に依存しているため、推移的依存 の状態になっています。

第3正規形の適用
この問題を解決するために、「役職」と「給与」を別のテーブルに分割 します。

① 社員情報テーブル（主キー：社員ID）
社員ID	                役職
101	                    マネージャー
102	                    エンジニア

② 役職情報テーブル（主キー：役職）
役職	                給与
マネージャー	        500万
エンジニア	            400万
こうすることで、「給与」が「役職」にのみ依存する形になり、推移的依存が解消されます。

第3正規形のメリット
データの整合性が向上 → 役職ごとの給与を一括管理できるため、更新時のミスを防げる。
冗長性の削減 → 同じ役職の給与情報を複数回記録する必要がなくなる。
データ更新の効率化 → 役職の給与を変更する際、1つのテーブルだけを修正すれば済む。