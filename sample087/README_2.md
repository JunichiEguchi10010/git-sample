DataBase データベース 正規化について 20250626

🔚正規化3段階の違いまとめ表
正規形	        意味	                        目的	            NGな例	                        解決方法
第1正規化	すべての値が原子値である	    繰り返しや配列を排除	カンマ区切りの値	            行を分ける
第2正規化	主キーの一部に依存しない	    部分関数従属を排除	   「名前」が「ID」にだけ依存	    エンティティを分離
第3正規化	主キー以外に推移的に依存しない	間接依存を排除	       「部署名」が「社員ID」に依存	    マスタ化して別テーブルへ

非正規化の代表パターン
🟡埋め込み（冗長な保持）
例：書籍テーブルに著者名を直接埋め込む
利点：ジョイン不要で表示が速い

🟡集計データの保持
例：注文テーブルに「商品数」や「合計金額」をあらかじめ持たせる

🟡履歴としての情報保持
例：注文時のユーザー名やメールアドレスを保持（後でユーザーが変更しても問題ないように）

🟡在庫数の保持
出入庫記録を毎回集計するのではなく、「現在の在庫数」を常に更新して保持

📘 マスターテーブルとトランザクションテーブル
✅ マスターテーブル：
変化の少ない「固定データ」（例：ユーザー情報、商品、都道府県など）

✅ トランザクションテーブル：
操作・出来事などの「履歴データ」（例：注文履歴、ログイン履歴など）




✅ 正規化3段階の実務的まとめ
【🔹第1正規化（1NF）】
◼️ 定義（原則として）
すべての列（属性）が原子値（＝1つの値）で構成されていること。

◼️ 実務的な意味
セルに複数の値を入れてはいけない
つまり、「配列」「カンマ区切り」「繰り返し項目」などはNG

◼️ 例（NG）
注文ID	商品名
001	    りんご,バナナ

「商品名」に2つの商品が入っている → NG（原子値でない）

◼️ 対応（OK）
注文ID	商品名
001	    りんご
001	    バナナ

データを1レコード1要素に分割 → 第1正規化OK

◼️ 実務でのポイント
観点	                                内容
入力欄の複数値やチェックボックス	  そのまま保存せず、中間テーブルなどで分けて管理
原子性の重要性	                    データの検索・更新・削除を正しく行うための最低条件

【🔹第2正規化（2NF）】
◼️ 定義（原則として）
第1正規化を満たし、かつ、主キーの一部にだけ依存する列（部分関数従属）がないこと。

◼️ 実務的な意味
複合主キー（2列以上のキー）でデータを識別しているときに注意
その一部の列だけに依存している情報は切り離す

◼️ 例（NG）
学生ID	        科目ID	    学生名	    点数
001	            A01	        田中	    90

主キーは（学生ID, 科目ID）
「学生名」は学生IDだけに依存している → 部分関数従属 → NG

◼️ 対応（OK）
分割して、IDを使ってエンティティ：実体（学生）を管理する：

学生テーブル
学生ID	    学生名
001	        田中

成績テーブル
学生ID	    科目ID	    点数
001	        A01	        90

◼️ 実務でのポイント
観点	                            内容
名前・商品名は一意とは限らない	    必ずIDを付与して管理
データの重複防止	              同じ名前を繰り返さずに済むため、保守性が向上

【🔹第3正規化（3NF）】
◼️ 定義（原則として）
第2正規化を満たし、かつ、主キー以外の列に依存している列（推移的関数従属）がないこと。

◼️ 実務的な意味
「主キー → 中間の列 → 他の列」という間接的な依存関係がある場合、それを切り離す

◼️ 例（NG）
社員ID	部署ID	部署名
001	    D01	    営業部

「部署名」は「部署ID」に依存している（中間項目）
つまり「社員ID → 部署ID → 部署名」という推移的従属 → NG

◼️ 対応（OK）
部署情報を独立させる：

社員テーブル
社員ID	部署ID
001	    D01

部署テーブル
部署ID	部署名
D01	    営業部

◼️ 実務でのポイント
観点	                                    内容
「説明情報」はコード（ID）と分けて管理	  部署名、カテゴリ名、都道府県名などはマスタ化
一括変更が容易になる	                部署名変更時、1か所だけ直せば済む ✅



✅ 第2正規化の実務的な説明まとめ
🔹定義（原則として）
第1正規化を満たしていて、かつ、主キーの一部にだけ依存する列（部分関数従属）がないこと。

🔸具体的な意味
主キーが**複数の列（複合キー）**でできている場合、
他の列（属性）が、その一部にだけ依存していたらNG。
→ そうした列は別のテーブルに分ける。

🔸実務的な要点（あなたの理解を反映）
項目	                    内容
氏名や製品名など	一意ではない可能性がある（同姓同名・類似品）

→ IDが必要	        安定して一意なIDを主キーにするのが正解
🔷🔷🔷 名前や製品名などは「一意性が保証されない」ことがあるため、IDを別途付与して管理する
→ これがデータベース設計の基本的な考え方です。🔷🔷🔷

複合キーがある場合	属性がその一部にだけ依存していたら「第2正規化違反」

対応方法	       部分的に依存しているデータを切り離して別テーブルへ

🔸例：成績テーブルでの問題と解決
🔻問題（第2正規化前）：
学生ID	    科目ID	    学生名	    点数
001	        A01	        田中	    90

主キーは（学生ID, 科目ID）
「学生名」は「学生ID」にだけ依存 → 第2正規化違反

✅解決（第2正規化後）：
学生テーブル（学生ID, 学生名）
成績テーブル（学生ID, 科目ID, 点数）
→ 「IDを用いてエンティティ（学生）を別テーブルで管理」＝正しい第2正規化

🔸まとめとしての定義（実務的バージョン）
第2正規化とは、主キーの一部にしか依存しない情報（名前や説明など）を分離し、IDによって管理対象を明確に切り分けること。
これは「重複をなくし、一意性を保ち、保守性を高めるため」の基本的なルールである。


🔷 主キー（ID）は、通常「数字を用いたID（=人工的に生成した一意な識別子）」が中心です。
これは実務・設計・パフォーマンス・安全性のすべての面で最も安定しています。

✅ なぜ「数字のID」が主流なのか？
以下の理由からです：

1. 一意性が保証しやすい
数値やシステムが発番した連番・UUIDなどは重複しない。

名前やメールアドレスは人間の入力ミス・変更がある。

2. 変更されにくい
数値のID（例：1234）は、原則「変更しないもの」として設計される。
一方で、名前やメールは「結婚」「引っ越し」「役職変更」で変わる。

3. 検索・JOINが速い
数値型はデータベース内部での処理が軽い（インデックス効率が良い）。
文字列や複合キーだと処理が重くなることがある。

4. 表現に揺れがない
「佐藤 太郎」と「佐藤太郎」「Sato Taro」は見た目は似てても別のデータになる可能性あり。
数字のIDはその点で完全に安定した識別子になる。

✅ 実際の例
エンティティ	    主キーとして使われるIDの例
顧客（Customer）	customer_id（例：1001）
社員（Employee）	employee_id（例：E0001）
商品（Product）	    product_id（例：P1204）
注文（Order）	    order_id（例：O230005）

✅ サロゲートキー（Surrogate Key）という考え方
「意味のない一意なID（例：自動採番された整数）を主キーに使う」という設計方針です。
これが現代の主流です。
「自然キー（名前や日付など意味のある値）」は主キーにはせず、別に保持します。

✅ 補足：数字以外の主キーもある？
一部では以下のようなケースもありますが、かなり慎重に扱います：

非数値ID	    利用例	                    備考
UUID（文字列）	グローバルに一意なID	モバイル・分散DBで使われる
メールアドレス	ログインIDとして	    主キーには不向き（変更あり）
ISBNコード	    書籍など	           管理機関が一意性を保証している場合のみOK

✅ 結論
主張	                内容
✅ 正しい	  「主キーは数値IDが中心」は正しい実務設計です
🚫 避けるべき	名前・メール・電話などを主キーにするのは危険
👍 推奨設計	   「意味のない数値ID」＋「補足情報（名前など）」が王道



🚫 一意性が満たされない一般的な項目（主キーに不適）
氏名（名前、フルネーム）
同姓同名の人はたくさんいる（例：「佐藤 太郎」）

🟡メールアドレス
一見一意に見えるが、変更されることがある
転用や誤登録・削除時の再利用もありえる

🟡電話番号
家族や会社で共有していることがある
携帯番号も変更される可能性あり

🟡住所
同一住所に複数人が住んでいる（例：家族、寮など）
書き方のゆれ（全角/半角、番地の順序など）

🟡生年月日
同じ誕生日の人はたくさんいる
他の項目と組み合わせなければ一意にならない

🟡商品名
同じ商品名でもバージョンや型番違いがある
同じ名前でリニューアルされる場合もある

🟡科目名
同じ「数学」や「英語」が複数の教育機関・年度で存在する

🟡部署名
会社によっては同じ「営業部」や「総務部」が複数存在する

🟡職種名
「エンジニア」「マネージャー」など汎用的で曖昧

🟡日付
同じ日付で複数のイベントやデータが存在可能

🟡顧客名 / 会社名
同名の企業、支店、個人事業主が存在することがある

✅ 一意性が満たされやすい項目（主キーに適切）
学生ID / 社員ID / 会員ID（システムが自動発番）
商品コード / SKU
注文番号
顧客ID
社内ユニークなメールID（変更不可ポリシーの場合）
UUID（グローバルに一意な識別子）

🔍 補足：一見ユニークでも避けたいケース
「社員番号」などの手入力ID
手動で付番していると、重複やミスのリスクがある
「顔写真」や「画像ファイル名」
ファイル名の重複、画像の再利用などで一意性を欠くことがある


🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯🎯


🎯 「テーブル設計・正規化・非正規化」の基礎と実践的な考え方

🔹 正規化（Normalization）とは
目的：データの重複や矛盾、更新ミスを防ぐための「テーブル分解のルール」
テーブル構造を整理し、「一貫性」「保守性」「効率性」を高める

🔸 正規化の3ステップ（第1〜第3正規化）
🔹 第1正規化（1NF）：
「繰り返し」を排除

例）著者1・著者2・著者3を縦持ちにする
→ データの整合性と拡張性が向上

🔹 第2正規化（2NF）：
主キーの一部にしか依存しない情報を別テーブルに分離
複合主キー（例：書籍ID＋著者名）を使う状況で、著者情報を中間テーブルに切り出す

🔹 第3正規化（3NF）：
推移的従属（主キー → 中間カラム → 他の情報）を排除
例：出版者IDを導入し、出版者情報を別テーブルに分ける

🔹 主キーの種類と使い分け
✅ 主キー（Primary Key）：
レコードを一意に識別するカラム（または複合カラム）
NULL不可、重複不可、1テーブル1つだけ

✅ 複合キー：
複数のカラムを組み合わせて一意性を担保
例：注文ID＋商品IDなど

✅ サロゲートキー（Surrogate Key）：
意味を持たない「自動採番のID」
例：Railsなどのフレームワークで主流（id: 1, 2, 3…）
利点：比較や連携が楽、管理しやすい
UUID他

🔸 現場での課題と非正規化の必要性
▶️ 正規化のデメリット（過度な場合）：
ジョインが多くなり、SQLが複雑化
パフォーマンス低下、分析困難になることも

🔹 非正規化（Denormalization）とは
あえて正規化を崩し、利便性や速度を優先する設計

非正規化の代表パターン
🟡埋め込み（冗長な保持）
例：書籍テーブルに著者名を直接埋め込む
利点：ジョイン不要で表示が速い

🟡集計データの保持
例：注文テーブルに「商品数」や「合計金額」をあらかじめ持たせる

🟡履歴としての情報保持
例：注文時のユーザー名やメールアドレスを保持（後でユーザーが変更しても問題ないように）

🟡在庫数の保持
出入庫記録を毎回集計するのではなく、「現在の在庫数」を常に更新して保持

💡 非正規化は「ビジネス理解」が不可欠
どの情報をいつ必要とするかの見通しが重要
ユースケースや業務要件によって正規化／非正規化の使い分けを行う

📘 マスターテーブルとトランザクションテーブル
✅ マスターテーブル：
変化の少ない「固定データ」（例：ユーザー情報、商品、都道府県など）

✅ トランザクションテーブル：
操作・出来事などの「履歴データ」（例：注文履歴、ログイン履歴など）

データ量が多く、更新されることが前提

🧠 最後に：良い設計とは？
正規化の理解 → 非正規化の判断 → データの性質を把握
「正しく整理」しながら「現場で使える形」にしていく
設計者の腕の見せ所は“崩す判断”


【超入門】現場で通用する「プロが教えるテーブル設計！」
https://www.youtube.com/watch?v=E6AgFIZEybM


✅ 第1正規化（1NF：First Normal Form）
🔹定義：
「繰り返しの項目がなく、すべての列（属性）が原子値であること」

🔸ポイント：
セルの中に複数の値が入っていないこと（＝「1つの値」だけ）
配列やカンマ区切りで複数の値が入っていたらNG

🔸NG例：
注文ID	商品名
001	りんご,バナナ
↑「りんご,バナナ」は複数の値（非原子値）なので1NF違反

✅ 第2正規化（2NF：Second Normal Form）
🔹定義：
「第1正規化を満たしていて、かつ、主キーの一部にだけ依存する項目（部分関数従属）がないこと」

🔸ポイント：
複合主キーの場合に注意！
列が「主キーの一部だけ」に依存していたらアウト（部分関数従属）

🔸NG例：
学生ID	科目ID	学生名	点数
001	    A01	    田中	90

→ 主キーは「学生ID, 科目ID」だけど、「学生名」は「学生ID」だけに依存 → NG
→ 「学生情報」と「成績情報」を分ける必要あり

✅ 第3正規化（3NF：Third Normal Form）
🔹定義：
「第2正規化を満たしていて、かつ、主キー以外の列に依存している列（推移的関数従属）がないこと」

🔸ポイント：
主キー → A → B のように、
主キー以外（A）を経由して別の列（B）に依存しているとNG
これを推移的関数従属という

🔸NG例：
社員ID	部署ID	部署名
001	    D01	    営業部

→ 主キーは「社員ID」だけど、「部署名」は「部署ID」に依存
→ 「社員ID → 部署ID → 部署名」という依存関係 → 推移的従属 → NG

→ 「部署ID, 部署名」は別テーブルに分ける

📝 まとめ表
正規形	        定義	                        　例でのNGポイント	        対応策
第1正規化	すべての値が原子値（1つの値）である	    1つのセルに複数の値	    値を行として分ける
第2正規化	主キーの一部にだけ依存する項目がない	複合キーの一部に依存	サブテーブルに分ける
第3正規化	主キー以外の列に推移的に依存しない	    主キー → 中間列 → 別列	中間列で別テーブルにする
