DataBase データベース 正規化について 20250626

🎯 「テーブル設計・正規化・非正規化」の基礎と実践的な考え方

🔹 正規化（Normalization）とは
目的：データの重複や矛盾、更新ミスを防ぐための「テーブル分解のルール」
テーブル構造を整理し、「一貫性」「保守性」「効率性」を高める

🔸 正規化の3ステップ（第1〜第3正規化）
🔹 第1正規化（1NF）：
「繰り返し」を排除

例）著者1・著者2・著者3を縦持ちにする
→ データの整合性と拡張性が向上

🔹 第2正規化（2NF）：
主キーの一部にしか依存しない情報を別テーブルに分離
複合主キー（例：書籍ID＋著者名）を使う状況で、著者情報を中間テーブルに切り出す

🔹 第3正規化（3NF）：
推移的従属（主キー → 中間カラム → 他の情報）を排除
例：出版者IDを導入し、出版者情報を別テーブルに分ける

🔹 主キーの種類と使い分け
✅ 主キー（Primary Key）：
レコードを一意に識別するカラム（または複合カラム）
NULL不可、重複不可、1テーブル1つだけ

✅ 複合キー：
複数のカラムを組み合わせて一意性を担保
例：注文ID＋商品IDなど

✅ サロゲートキー（Surrogate Key）：
意味を持たない「自動採番のID」
例：Railsなどのフレームワークで主流（id: 1, 2, 3…）
利点：比較や連携が楽、管理しやすい
UUID他

🔸 現場での課題と非正規化の必要性
▶️ 正規化のデメリット（過度な場合）：
ジョインが多くなり、SQLが複雑化
パフォーマンス低下、分析困難になることも

🔹 非正規化（Denormalization）とは
あえて正規化を崩し、利便性や速度を優先する設計

非正規化の代表パターン
🟡埋め込み（冗長な保持）
例：書籍テーブルに著者名を直接埋め込む
利点：ジョイン不要で表示が速い

🟡集計データの保持
例：注文テーブルに「商品数」や「合計金額」をあらかじめ持たせる

🟡履歴としての情報保持
例：注文時のユーザー名やメールアドレスを保持（後でユーザーが変更しても問題ないように）

🟡在庫数の保持
出入庫記録を毎回集計するのではなく、「現在の在庫数」を常に更新して保持

💡 非正規化は「ビジネス理解」が不可欠
どの情報をいつ必要とするかの見通しが重要
ユースケースや業務要件によって正規化／非正規化の使い分けを行う

📘 マスターテーブルとトランザクションテーブル
✅ マスターテーブル：
変化の少ない「固定データ」（例：ユーザー情報、商品、都道府県など）

✅ トランザクションテーブル：
操作・出来事などの「履歴データ」（例：注文履歴、ログイン履歴など）

データ量が多く、更新されることが前提

🧠 最後に：良い設計とは？
正規化の理解 → 非正規化の判断 → データの性質を把握
「正しく整理」しながら「現場で使える形」にしていく
設計者の腕の見せ所は“崩す判断”


【超入門】現場で通用する「プロが教えるテーブル設計！」
https://www.youtube.com/watch?v=E6AgFIZEybM