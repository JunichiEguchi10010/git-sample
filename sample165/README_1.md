コードレビューの基本からGitHubでの実務的な手順 20250908

✅ 正解がないので事前にレビューの目的を共有しないとブレる
・多数ある場合は優先順位を付ける
・動作確認をレビュアーは確認するのか？コードのみ確認するのか？

✅ 実際のレビューでの具体的なレビューの観点の例
・使用漏れや使用を誤解したコードになっていないか？
・異常系の処理、例外処理が 適切に書かれているか？
・テストコードがある場合はテストケースに漏れがないか？
・コードの構造がチームが採用している設計やルールに則っているか？
・SQL インジェクション対策などセキュリティに 関する問題はないか？
・n+1問題など パフォーマンスに問題が生じるようなコードは入っていないか？
・マジック ナンバーの使用や適切ではないハードコーディングはないか？

このようなことが よくある具体的なレビューの観点の例です 。


1️⃣ コードレビューの基本

目的: コードの品質向上、バグ防止、チーム内の知識共有。

登場人物
レビューE（エンジニア）: コードを書いた人
レビューアー: コードを確認・提案する人

レビューの流れ
コード作成 → 修正・追加
レビュー依頼（Pull Request）
レビューアーがコメント・提案
レビューEが修正
承認（Approve）されればマージ

2️⃣ レビュー時の観点（例）
使用漏れや誤用がないか
異常系・例外処理が正しいか
テストケースの漏れがない
コード設計・チームルールに沿っているか
セキュリティやパフォーマンスの問題はないか
マジックナンバーやハードコーディングの不適切な使用はないか
※優先順位は、セキュリティ・バグ・誤用の順に重要度が高い

3️⃣ レビューアーの心構え
対等の関係で行う（上下関係ではない）
ダメ出しではなく建設的提案
具体的な修正案を示すと分かりやすい
良い部分を褒めることも重要

4️⃣ レビューEの心構え
適切な量でレビュー依頼（細かく分ける）
コードは整形・テスト済みにしてお
コードの意図・機能を事前に共有（デザインドキュメントなど作成し共有)
→ Design Docsとは、何を・なぜ・どう実装するかを表す。
指摘を恐れず、学びとして受け止める
提案を必ず採用する必要はない

5️⃣ GitHubでのレビュー操作（基本）　プライベートは有料
ブランチ作成: メイン → フィーチャーブランチ
コード変更 → コミット → プッシュ
Pull Request作成
レビューアー指定
→ 🔹 GitHub Copilotを Reviewersに指定することも可能
アサイン（レビューE指定）
PR本文に目的・実装内容・デザインドキュメントリンク記載

レビューアー側
Files changesで差分確認
コメント追加（単発 or スタートレビューでまとめ）
コード修正提案（Add suggestion）
提案に対してApprove / Request changes / Comment

レビューE側
指摘に対応 → 修正 → 再コミット
コメント返信・提案採用 or 拒否
最終的にレビューアーがApprove → マージ可能


💡 ポイント
複数回の往復が普通
コードと自分を切り離して考える
Pull Request本文やデザインドキュメントで意図を共有するとレビューがスムーズ
GitHubの操作は、コメント・提案・Approve/Request changesを使い分ける


【コードレビューのやり方】初心者向け〜GitHubでの操作も解説！〜
https://www.youtube.com/watch?v=1ItmFLy0A1s


🔹 N+1問題とは？
データベースを使うプログラムでよく出てくる パフォーマンスの落とし穴 です。
特に ORM（Django, Rails, SQLAlchemy など）を使った時によく起こります。

🔹 例え話
例えば「ユーザーとその投稿一覧」を表示したいとします。
最初の1回目のクエリ (N+1の“1”)
まず全ユーザーを取ってきます。

SELECT * FROM users;


→ ここでユーザーが100人いました。

N回目のクエリ (N+1の“N”)
次に、各ユーザーごとに投稿を取得します。

SELECT * FROM posts WHERE user_id = 1;
SELECT * FROM posts WHERE user_id = 2;
...
SELECT * FROM posts WHERE user_id = 100;

→ ユーザーの数だけ（この場合100回）クエリが発行されます。

結果として、
合計で 1 + 100 = 101 回クエリ が走ることになります。
これが N+1問題 です。

🔹 なぜ問題？
クエリの回数が増えるほど DBへのアクセスが遅くなる
データ量やユーザー数が増えると、 爆発的に遅くなる

🔹 解決方法

JOINを使う

SELECT users.*, posts.* 
FROM users 
LEFT JOIN posts ON users.id = posts.user_id;

事前にまとめて取得 (Eager Loading)
→ Django の select_related, Rails の includes, SQLAlchemy の joinedload など

👉 簡単にいうと、
「1回のクエリでまとめて取れるのに、無駄に何回もクエリを発行してしまう」
のが N+1問題です。